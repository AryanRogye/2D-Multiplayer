#include "pa;5uCKETuuuu;5u;5u;5u hh ft ftzzz.H"

/**
 * FIGURE OUT WHAT THE PACKET TYPE IS
 * @PARAM BUFFER: THE BUFFER THAT CONTAINS THE PACKET
 * @PARAM OFFSET: THE OFFSET IN THE BUFFER WHERE THE PACKET TYPE IS LOCATED
 *  THIS GETS UPDATED TO THE NEXT OFFSET SO THAT YOU CAN CONTINUE READING THE REST OF THE PACKET
 **/
PACKETTYPE SERIALIZABLE::GET_PACKET_TYPE(CONST UINT8_T *BUFFER, SIZE_T *OFFSET) 
{
    // THE FIRST BYTE OF THE BUFFER IS THE PACKET TYPE
    PACKETTYPE TYPE;
    STD::MEMCPY(&TYPE, BUFFER, SIZEOF(TYPE));
    *OFFSET += SIZEOF(TYPE);
    RETURN TYPE;
}

// ############################################################
// ############# PLAYER JOINED IMPLEMENTATION #################
// ############################################################

/** INIT A PLAYER JOINED OBJECT WITH A NAME **/
PLAYERJOINED::PLAYERJOINED(CONST STD::STRING& NAME)
{
    THIS->ID = -1;
    STD::MEMSET(THIS->NAME, 0, SIZEOF(THIS->NAME));
    STD::STRNCPY(THIS->NAME, NAME.C_STR(), SIZEOF(THIS->NAME) - 1);
}

/** INIT A PLAYER JOINED OBJECT WITH AN ID AND NAME **/
PLAYERJOINED::PLAYERJOINED(INT ID, CONST STD::STRING& NAME) : ID(ID)
{
    STD::MEMSET(THIS->NAME, 0, SIZEOF(THIS->NAME));
    STD::STRNCPY(THIS->NAME, NAME.C_STR(), SIZEOF(THIS->NAME) - 1);
}

// SETTERS FOR PLAYERJOINED
VOID PLAYERJOINED::SETID(INT ID) { THIS->ID = ID; }
VOID PLAYERJOINED::SETNAME(CONST STD::STRING& NAME) { STD::STRNCPY(THIS->NAME, NAME.C_STR(), SIZEOF(THIS->NAME) - 1); }
// GETTERS FOR PLAYERJOINED
INT PLAYERJOINED::GETID() CONST { RETURN THIS->ID; }
STD::STRING PLAYERJOINED::GETNAME() CONST { RETURN STD::STRING(THIS->NAME); }

/** SERIALIZE THE PLAYERJOINED PACKET **/
SIZE_T PLAYERJOINED::SERIALIZE(UINT8_T* BUFFER)
{
    SIZE_T OFFSET = 0;
    // SERIALIZE THE ENUM COORESPONDING TO THE PACKET TYPE
    PACKETTYPE TYPE = PACKETTYPE::PLAYER_JOINED;
    STD::MEMCPY(BUFFER + OFFSET, &TYPE, SIZEOF(TYPE));
    OFFSET += SIZEOF(TYPE);
    // FIRST SERIALIZE THE ID
    STD::MEMCPY(BUFFER + OFFSET, &THISuuk->id, sizeof(this->id));
    offset += sizeof(this->id);

    // Serialize the name
    std::memcpy(buffer + offset, this->name, sizeof(this->name));
    offset += sizeof(this->name);

    return offset;
}

/** Deserialize the PlayerJoined Packet **/
void PlayerJoined::deserialize(const uint8_t *buffer, size_t *offset)
{
    // Deserialize id
    std::memcpy(&this->id, buffer + *offset, sizeof(this->id));
    *offset += sizeof(this->id);

    // Deserialize name content
    std::memcpy(this->name, buffer + *offset, sizeof(this->name));
    *offset += sizeof(this->name);
}

// ############################################################
// ############### PlayerMoved Implementation #################
// ############################################################

/** Init The Player Moved with an id and x,y positions **/
PlayerMoved::PlayerMoved(int id, float x, float y) 
{
    this->id = id;
    this->x = x;
    this->y = y;
}

// Setters for PlayerMoved
void PlayerMoved::setID(int id) { this->id = id; }
void PlayerMoved::setX(float x) { this->x = x; }
void PlayerMoved::setY(float y) { this->y = y; }
// Getters for PlayerMoved
int PlayerMoved::getID() const { return this->id; }
float PlayerMoved::getX() const { return this->x; }
float PlayerMoved::getY() const { return this->y; }

/** Serialize the PlayerMoved Packet **/
size_t PlayerMoved::serialize(uint8_t *buffer)
{
    size_t offset = 0;
    // Serialize The Enum cooresponding to the packet type
    PacketType type = PacketType::PLAYER_MOVED;
    std::memcpy(buffer + offset, &type, sizeof(type));
    offset += sizeof(type);
    // Serialize id
    std::memcpy(buffer + offset, &this->id, sizeof(this->id));
    offset += sizeof(this->id);

    // Serialize x
    std::memcpy(buffer + offset, &this->x, sizeof(this->x));
    offset += sizeof(this->x);

    // Serialize y
    std::memcpy(buffer + offset, &this->y, sizeof(this->y));
    offset += sizeof(this->y);

    return offset;
}

/** Deserialize the PlayerMoved Packet **/
void PlayerMoved::deserialize(const uint8_t *buffer, size_t *offset)
{
    // Deserialize id
    std::memcpy(&this->id, buffer + *offset, sizeof(this->id));
    *offset += sizeof(this->id);

    // Deserialize x
    std::memcpy(&this->x, buffer + *offset, sizeof(this->x));
    *offset += sizeof(this->x);

    // Deserialize y
    std::memcpy(&this->y, buffer + *offset, sizeof(this->y));
    *offset += sizeof(this->y);
}

// ############################################################
// ############# AssignID Implementation ######################
// ############################################################

/** Init The AssignPlayerID with an id **/
AssignPlayerID::AssignPlayerID(int id) 
{
    this->id = id;
}
// Getters for AssignPlayerID
int AssignPlayerID::getID() const { return this->id; }

/** Serialize the AssignPlayerID Packet **/
size_t AssignPlayerID::serialize(uint8_t *buffer)
{
    size_t offset = 0;
    // Serialize The Enum cooresponding to the packet type
    PacketType type = PacketType::ASSIGN_PLAYER_ID;
    std::memcpy(buffer + offset, &type, sizeof(type));
    offset += sizeof(type);

    // Serialize id
    std::memcpy(buffer + offset, &this->id, sizeof(this->id));
    offset += sizeof(this->id);

    return offset;
}

/** Deserialize the AssignPlayerID Packet **/
void AssignPlayerID::deserialize(const uint8_t *buffer, size_t *offset)
{
    // Deserialize id
    std::memcpy(&this->id, buffer + *offset, sizeof(this->id));
    *offset += sizeof(this->id);
}


// ############################################################
// ##### SendExistingClientsToNewPlayer Implementation ########
// ############################################################

SendExistingClientsToNewPlayer::SendExistingClientsToNewPlayer(std::vector<Player>& players)
{
    this->players = players;
}

std::vector<Player>& SendExistingClientsToNewPlayer::getPlayers()
{
    return this->players;
}

size_t SendExistingClientsToNewPlayer::serialize(uint8_t *buffer)
{
    size_t offset = 0;

    // Serialize The Enum corresponding to the packet type
    PacketType type = PacketType::SEND_EXISTING_CLIENTS_NEW_PLAYER;
    std::memcpy(buffer + offset, &type, sizeof(type));
    offset += sizeof(type);

    // Serialize the number of players
    int num_players = this->players.size();
    std::memcpy(buffer + offset, &num_players, sizeof(num_players));
    offset += sizeof(num_players);

    // Serialize each Player object
    for (Player& player : this->players)
    {
        size_t playerSize = player.serialize(buffer + offset);
        offset += playerSize;
    }
    return offset;
}

void SendExistingClientsToNewPlayer::deserialize(const uint8_t *buffer, size_t *offset)
{
    // Deserialize player_ids
    int num_players;
    std::memcpy(&num_players, buffer + *offset, sizeof(num_players));
    *offset += sizeof(num_players);

    std::cout << "Got The Number of Players: " << num_players << std::endl;

    // Deserialize each player
    for (int i = 0; i < num_players; i++)
    {
        Player player;
        player.deserialize(buffer, offset);
        this->players.push_back(player);
    }
}

// ############################################################
// ###### SendToExisitingClientsNewPlayer Implementation ######
// ############################################################

SendToExisitingClientsNewPlayer::SendToExisitingClientsNewPlayer(int id)
{
    this->id = id;
}

size_t SendToExisitingClientsNewPlayer::serialize(uint8_t *buffer)
{
    // Serialize The Enum cooresponding to the packet type
    PacketType type = PacketType::SEND_NEW_PLAYER_EXISTING_CLIENTS;
    std::memcpy(buffer, &type, sizeof(type));
    size_t offset = sizeof(type);

    // Serialize id
    std::memcpy(buffer + offset, &this->id, sizeof(this->id));
    offset += sizeof(this->id);
    
    return offset;
}

void SendToExisitingClientsNewPlayer::deserialize(const uint8_t *buffer, size_t *offset)
{
    // Deserialize id
    std::memcpy(&this->id, buffer + *offset, sizeof(this->id));
    *offset += sizeof(this->id);
}
