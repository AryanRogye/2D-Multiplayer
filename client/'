/** 
 * Purpose Of this file is to define the block structure and the 
 * functions that will be used to manipulate the block
 **/

/**
 * Restructuring This Entire File To Follow The Design Pattern of 
 * Compostion Over Inheritance For the Block Class The reason why
 * is cuz some blocks have absolutely 0 purpose to inherit from and
 * if we do inherit itll have a bunch of useless functions that just
 * add a bunch of memory overhead and slow down the program
 **/

#pragma once
#include <memory>
#ifndef BLOCK_H
#define BLOCK_H

#include <unordered_map>
#include <configs.h>
#include <string>
#include <vector>
#include <iostream>

enum class BlockType {
    GRASS,
    HORIZONTAL_DIRT,
    VERTICAL_DIRT,
    VERTICAL_LEFT_DIRT,
    INTERSECTION_DIRT,
    TREE,
    HORIZONTAL_UP_DIRT,
    VERTICAL_RIGHT_DIRT,
    HORIZONTAL_DOWN_DIRT,
    TOP_LEFT_CORNER_DIRT,
    TOP_RIGHT_CORNER_DIRT,
    BOTTOM_RIGHT_CORNER_DIRT,
    BOTTOM_LEFT_CORNER_DIRT,
    HOUSE,
    SINGLE_FENCE,
    FENCE_ROW,
    RIGHT_END_FENCE,
    LEFT_END_FENCE,
    TOP_END_FENCE,
    BOTTOM_END_FENCE,
    TOP_LEFT_CORNER_FENCE,
    TOP_RIGHT_CORNER_FENCE,
    BOTTOM_RIGHT_CORNER_FENCE,
    BOTTOM_LEFT_CORNER_FENCE,
    FENCE_COL,
    HOUSE_BIG,
    EMPTY
};
class BlockComponent {
public:
    virtual ~BlockComponent() = default;
};
class CollisionComponent : public BlockComponent {
    bool isSolid;
public:
    CollisionComponent(bool isSolid);
    bool getIsSolid() const;
};
class Block {
public:
    BlockType type;
    std::string name;
    std::vector<std::unique_ptr<BlockComponent>> components;

    Block(BlockType type);

    template <typename T, typename... Args>
    void addComponent(Args&&... args) {
        components.push_back(std::make_unique<T>(std::forward<Args>(args)...));
    }

    template <typename T>
    T* getComponent() {
        for (auto& comp : components) {
            if (auto ptr = dynamic_cast<T*>(comp.get())) return ptr;
        }
        return nullptr;
    }
};


class Block {
private:
    /** This is used to store the old block type 
     *  so we dont spam the console with the same block type
     **/
    static BlockType oldBlockType;
public:
    BlockType type;
    std::string name;
    bool isSolid;

    Block(BlockType type, bool isSolid = false);

    static BlockType getBlockTypeFromString(const std::string& name);
    static std::string getBlockName(BlockType type);

    void printBlockInfo() const;
    static void printBlockInfoByPosition(int x, int y, const std::vector<std::vector<int>>& mapData);
};

#endif // BLOCK_H
